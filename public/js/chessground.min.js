var Ge = ["white", "black"];
var I = ["a", "b", "c", "d", "e", "f", "g", "h"],
   U = ["1", "2", "3", "4", "5", "6", "7", "8"];
var We = [...U].reverse(),
   Q = I.flatMap((e) => U.map((o) => e + o)),
   L = (e) => (e.every((o) => o >= 0 && o <= 7) ? Q[8 * e[0] + e[1]] : void 0),
   G = (e) => L(e),
   m = (e) => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49];
var be = Q.map(m),
   $e = Q.map((e, o) => ({ key: e, pos: be[o] }));
function he(e) {
   let o,
      t = () => (o === void 0 && (o = e()), o);
   return (
      (t.clear = () => {
         o = void 0;
      }),
      t
   );
}
var ze = () => {
      let e;
      return {
         start() {
            e = performance.now();
         },
         cancel() {
            e = void 0;
         },
         stop() {
            if (!e) return 0;
            let o = performance.now() - e;
            return ((e = void 0), o);
         },
      };
   },
   F = (e) => (e === "white" ? "black" : "white"),
   W = (e, o) => (e[0] - o[0]) ** 2 + (e[1] - o[1]) ** 2,
   Y = (e, o) => e.role === o.role && e.color === o.color,
   Ie = (e, o) => e[0] === o[0] && e[1] === o[1],
   $ = (e) => (o, t) => [
      ((t ? o[0] : 7 - o[0]) * e.width) / 8,
      ((t ? 7 - o[1] : o[1]) * e.height) / 8,
   ],
   x = (e, o) => {
      e.style.transform = `translate(${o[0]}px,${o[1]}px)`;
   },
   ve = (e, o, t = 1) => {
      e.style.transform = `translate(${o[0]}px,${o[1]}px) scale(${t})`;
   },
   q = (e, o) => {
      e.style.visibility = o ? "visible" : "hidden";
   },
   T = (e) => {
      if (e.clientX || e.clientX === 0) return [e.clientX, e.clientY];
      if (e.targetTouches?.[0])
         return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
   },
   et = he(
      () =>
         !("ontouchstart" in window) &&
         ["macintosh", "firefox"].every((e) =>
            navigator.userAgent.toLowerCase().includes(e),
         ),
   ),
   re = (e) => e.button === 2 && !(e.ctrlKey && et()),
   C = (e, o) => {
      let t = document.createElement(e);
      return (o && (t.className = o), t);
   };
function ie(e, o, t) {
   let n = m(e);
   return (
      o || ((n[0] = 7 - n[0]), (n[1] = 7 - n[1])),
      [
         t.left + (t.width * n[0]) / 8 + t.width / 16,
         t.top + (t.height * (7 - n[1])) / 8 + t.height / 16,
      ]
   );
}
var R = (e, o) => Math.abs(e - o),
   ae = (e, o, t, n) => R(e, t) * R(o, n) === 2,
   ye = (e, o, t, n) => (e === t) != (o === n),
   Se = (e, o, t, n) => R(e, t) === R(o, n) && e !== t,
   je = (e, o, t, n) => ye(e, o, t, n) || Se(e, o, t, n),
   Ue = (e, o, t, n) => Math.max(R(e, t), R(o, n)) === 1;
var Ze = (e, o, t, n, r) => {
      let i = r ? 1 : -1;
      return (
         e === t && (n === o + i || (n === o + 2 * i && (r ? o <= 1 : o >= 6)))
      );
   },
   _e = (e, o, t, n) => {
      let r = t - e,
         i = n - o;
      if (r && i && Math.abs(r) !== Math.abs(i)) return [];
      let c = Math.sign(r),
         p = Math.sign(i),
         d = [],
         a = e + c,
         s = o + p;
      for (; a !== t || s !== n; ) (d.push([a, s]), (a += c), (s += p));
      return d.map(L).filter((l) => l !== void 0);
   };
var ot = (e) =>
      R(e.orig.pos[0], e.dest.pos[0]) <= 1 &&
      (R(e.orig.pos[0], e.dest.pos[0]) === 1
         ? e.dest.pos[1] === e.orig.pos[1] + (e.color === "white" ? 1 : -1)
         : Ze(...e.orig.pos, ...e.dest.pos, e.color === "white")),
   tt = (e) => ae(...e.orig.pos, ...e.dest.pos),
   Xe = (e) => Se(...e.orig.pos, ...e.dest.pos),
   Qe = (e) => ye(...e.orig.pos, ...e.dest.pos),
   nt = (e) => Xe(e) || Qe(e),
   rt = (e) =>
      Ue(...e.orig.pos, ...e.dest.pos) ||
      (e.orig.pos[1] === e.dest.pos[1] &&
         e.orig.pos[1] === (e.color === "white" ? 0 : 7) &&
         ((e.orig.pos[0] === 4 &&
            ((e.dest.pos[0] === 2 && e.rookFilesFriendlies.includes(0)) ||
               (e.dest.pos[0] === 6 && e.rookFilesFriendlies.includes(7)))) ||
            e.rookFilesFriendlies.includes(e.dest.pos[0]))),
   it = { pawn: ot, knight: tt, bishop: Xe, rook: Qe, queen: nt, king: rt };
function we(e, o) {
   let t = e.pieces,
      n = t.get(o);
   if (!n || n.color === e.turnColor) return [];
   let r = n.color,
      i = new Map([...t].filter(([s, l]) => l.color === r)),
      c = new Map([...t].filter(([s, l]) => l.color === F(r))),
      p = { key: o, pos: m(o) },
      d = (s) => it[n.role](s) && e.premovable.additionalPremoveRequirements(s),
      a = {
         orig: p,
         role: n.role,
         allPieces: t,
         friendlies: i,
         enemies: c,
         color: r,
         rookFilesFriendlies: Array.from(t)
            .filter(
               ([s, l]) =>
                  s[1] === (r === "white" ? "1" : "8") &&
                  l.color === r &&
                  l.role === "rook",
            )
            .map(([s]) => m(s)[0]),
         lastMove: e.lastMove,
      };
   return $e.filter((s) => d({ ...a, dest: s })).map((s) => s.key);
}
function P(e, ...o) {
   e && setTimeout(() => e(...o), 1);
}
function Ye(e) {
   ((e.orientation = F(e.orientation)),
      (e.animation.current = e.draggable.current = e.selected = void 0));
}
function Je(e, o) {
   for (let [t, n] of o) n ? e.pieces.set(t, n) : e.pieces.delete(t);
}
function eo(e, o) {
   if (((e.check = void 0), o === !0 && (o = e.turnColor), o))
      for (let [t, n] of e.pieces)
         n.role === "king" && n.color === o && (e.check = t);
}
function at(e, o, t, n) {
   (D(e), (e.premovable.current = [o, t]), P(e.premovable.events.set, o, t, n));
}
function K(e) {
   e.premovable.current &&
      ((e.premovable.current = void 0), P(e.premovable.events.unset));
}
function ct(e, o, t) {
   (K(e),
      (e.predroppable.current = { role: o, key: t }),
      P(e.predroppable.events.set, o, t));
}
function D(e) {
   let o = e.predroppable;
   o.current && ((o.current = void 0), P(o.events.unset));
}
function st(e, o, t) {
   if (!e.autoCastle) return !1;
   let n = e.pieces.get(o);
   if (!n || n.role !== "king") return !1;
   let r = m(o),
      i = m(t);
   if ((r[1] !== 0 && r[1] !== 7) || r[1] !== i[1]) return !1;
   r[0] === 4 &&
      !e.pieces.has(t) &&
      (i[0] === 6 ? (t = G([7, i[1]])) : i[0] === 2 && (t = G([0, i[1]])));
   let c = e.pieces.get(t);
   return !c || c.color !== n.color || c.role !== "rook"
      ? !1
      : (e.pieces.delete(o),
        e.pieces.delete(t),
        r[0] < i[0]
           ? (e.pieces.set(G([6, i[1]]), n), e.pieces.set(G([5, i[1]]), c))
           : (e.pieces.set(G([2, i[1]]), n), e.pieces.set(G([3, i[1]]), c)),
        !0);
}
function Pe(e, o, t) {
   let n = e.pieces.get(o),
      r = e.pieces.get(t);
   if (o === t || !n) return !1;
   let i = r && r.color !== n.color ? r : void 0;
   return (
      t === e.selected && w(e),
      P(e.events.move, o, t, i),
      st(e, o, t) || (e.pieces.set(t, n), e.pieces.delete(o)),
      (e.lastMove = [o, t]),
      (e.check = void 0),
      P(e.events.change),
      i || !0
   );
}
function ce(e, o, t, n) {
   if (e.pieces.has(t))
      if (n) e.pieces.delete(t);
      else return !1;
   return (
      P(e.events.dropNewPiece, o, t),
      e.pieces.set(t, o),
      (e.lastMove = [t]),
      (e.check = void 0),
      P(e.events.change),
      (e.movable.dests = void 0),
      (e.turnColor = F(e.turnColor)),
      !0
   );
}
function oo(e, o, t) {
   let n = Pe(e, o, t);
   return (
      n &&
         ((e.movable.dests = void 0),
         (e.turnColor = F(e.turnColor)),
         (e.animation.current = void 0)),
      n
   );
}
function Me(e, o, t) {
   if (le(e, o, t)) {
      let n = oo(e, o, t);
      if (n) {
         let r = e.hold.stop();
         w(e);
         let i = { premove: !1, ctrlKey: e.stats.ctrlKey, holdTime: r };
         return (
            n !== !0 && (i.captured = n),
            P(e.movable.events.after, o, t, i),
            !0
         );
      }
   } else if (dt(e, o, t))
      return (at(e, o, t, { ctrlKey: e.stats.ctrlKey }), w(e), !0);
   return (w(e), !1);
}
function se(e, o, t, n) {
   let r = e.pieces.get(o);
   (r && (lt(e, o, t) || n)
      ? (e.pieces.delete(o),
        ce(e, r, t, n),
        P(e.movable.events.afterNewPiece, r.role, t, {
           premove: !1,
           predrop: !1,
        }))
      : r && pt(e, o, t)
        ? ct(e, r.role, t)
        : (K(e), D(e)),
      e.pieces.delete(o),
      w(e));
}
function J(e, o, t) {
   if ((P(e.events.select, o), e.selected)) {
      if (e.selected === o && !e.draggable.enabled) {
         (w(e), e.hold.cancel());
         return;
      } else if (
         (e.selectable.enabled || t) &&
         e.selected !== o &&
         Me(e, e.selected, o)
      ) {
         e.stats.dragged = !1;
         return;
      }
   }
   (e.selectable.enabled || e.draggable.enabled) &&
      (to(e, o) || Ce(e, o)) &&
      (xe(e, o), e.hold.start());
}
function xe(e, o) {
   ((e.selected = o),
      Ce(e, o)
         ? e.premovable.customDests || (e.premovable.dests = we(e, o))
         : (e.premovable.dests = void 0));
}
function w(e) {
   ((e.selected = void 0), (e.premovable.dests = void 0), e.hold.cancel());
}
function to(e, o) {
   let t = e.pieces.get(o);
   return (
      !!t &&
      (e.movable.color === "both" ||
         (e.movable.color === t.color && e.turnColor === t.color))
   );
}
var le = (e, o, t) =>
   o !== t &&
   to(e, o) &&
   (e.movable.free || !!e.movable.dests?.get(o)?.includes(t));
function lt(e, o, t) {
   let n = e.pieces.get(o);
   return (
      !!n &&
      (o === t || !e.pieces.has(t)) &&
      (e.movable.color === "both" ||
         (e.movable.color === n.color && e.turnColor === n.color))
   );
}
function Ce(e, o) {
   let t = e.pieces.get(o);
   return (
      !!t &&
      e.premovable.enabled &&
      e.movable.color === t.color &&
      e.turnColor !== t.color
   );
}
var dt = (e, o, t) =>
   o !== t &&
   Ce(e, o) &&
   (e.premovable.customDests?.get(o) ?? we(e, o)).includes(t);
function pt(e, o, t) {
   let n = e.pieces.get(o),
      r = e.pieces.get(t);
   return (
      !!n &&
      (!r || r.color !== e.movable.color) &&
      e.predroppable.enabled &&
      (n.role !== "pawn" || (t[1] !== "1" && t[1] !== "8")) &&
      e.movable.color === n.color &&
      e.turnColor !== n.color
   );
}
function no(e, o) {
   let t = e.pieces.get(o);
   return (
      !!t &&
      e.draggable.enabled &&
      (e.movable.color === "both" ||
         (e.movable.color === t.color &&
            (e.turnColor === t.color || e.premovable.enabled)))
   );
}
function ro(e) {
   let o = e.premovable.current;
   if (!o) return !1;
   let t = o[0],
      n = o[1],
      r = !1;
   if (le(e, t, n)) {
      let i = oo(e, t, n);
      if (i) {
         let c = { premove: !0 };
         (i !== !0 && (c.captured = i),
            P(e.movable.events.after, t, n, c),
            (r = !0));
      }
   }
   return (K(e), r);
}
function io(e, o) {
   let t = e.predroppable.current,
      n = !1;
   if (!t) return !1;
   if (o(t)) {
      let r = { role: t.role, color: e.movable.color };
      ce(e, r, t.key) &&
         (P(e.movable.events.afterNewPiece, t.role, t.key, {
            premove: !1,
            predrop: !0,
         }),
         (n = !0));
   }
   return (D(e), n);
}
function ee(e) {
   (K(e), D(e), w(e));
}
function ke(e) {
   ((e.movable.color = e.movable.dests = e.animation.current = void 0), ee(e));
}
function E(e, o, t) {
   let n = Math.floor((8 * (e[0] - t.left)) / t.width);
   o || (n = 7 - n);
   let r = 7 - Math.floor((8 * (e[1] - t.top)) / t.height);
   return (
      o || (r = 7 - r),
      n >= 0 && n < 8 && r >= 0 && r < 8 ? L([n, r]) : void 0
   );
}
function ao(e, o, t, n) {
   let r = m(e),
      i = be.filter(
         (a) =>
            Ie(r, a) ||
            je(r[0], r[1], a[0], a[1]) ||
            ae(r[0], r[1], a[0], a[1]),
      ),
      p = i.map((a) => ie(G(a), t, n)).map((a) => W(o, a)),
      [, d] = p.reduce((a, s, l) => (a[0] < s ? a : [s, l]), [p[0], 0]);
   return L(i[d]);
}
var h = (e) => e.orientation === "white";
var De = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR",
   ut = {
      p: "pawn",
      r: "rook",
      n: "knight",
      b: "bishop",
      q: "queen",
      k: "king",
   },
   gt = {
      pawn: "p",
      rook: "r",
      knight: "n",
      bishop: "b",
      queen: "q",
      king: "k",
   };
function de(e) {
   e === "start" && (e = De);
   let o = new Map(),
      t = 7,
      n = 0;
   for (let r of e)
      switch (r) {
         case " ":
         case "[":
            return o;
         case "/":
            if ((--t, t < 0)) return o;
            n = 0;
            break;
         case "~": {
            let i = L([n - 1, t]),
               c = i && o.get(i);
            c && (c.promoted = !0);
            break;
         }
         default: {
            let i = r.charCodeAt(0);
            if (i < 57) n += i - 48;
            else {
               let c = r.toLowerCase(),
                  p = L([n, t]);
               (p &&
                  o.set(p, { role: ut[c], color: r === c ? "black" : "white" }),
                  ++n);
            }
         }
      }
   return o;
}
function co(e) {
   return We.map((o) =>
      I.map((t) => {
         let n = e.get(t + o);
         if (n) {
            let r = gt[n.role];
            return (
               n.color === "white" && (r = r.toUpperCase()),
               n.promoted && (r += "~"),
               r
            );
         } else return "1";
      }).join(""),
   )
      .join("/")
      .replace(/1{2,}/g, (o) => o.length.toString());
}
function Ee(e, o) {
   o.animation &&
      (Ae(e.animation, o.animation),
      (e.animation.duration || 0) < 70 && (e.animation.enabled = !1));
}
function pe(e, o) {
   if (
      (o.movable?.dests && (e.movable.dests = void 0),
      o.drawable?.autoShapes && (e.drawable.autoShapes = []),
      Ae(e, o),
      o.fen &&
         ((e.pieces = de(o.fen)),
         (e.drawable.shapes = o.drawable?.shapes || [])),
      "check" in o && eo(e, o.check || !1),
      "lastMove" in o && !o.lastMove
         ? (e.lastMove = void 0)
         : o.lastMove && (e.lastMove = o.lastMove),
      e.selected && xe(e, e.selected),
      Ee(e, o),
      !e.movable.rookCastle && e.movable.dests)
   ) {
      let t = e.movable.color === "white" ? "1" : "8",
         n = "e" + t,
         r = e.movable.dests.get(n),
         i = e.pieces.get(n);
      if (!r || !i || i.role !== "king") return;
      e.movable.dests.set(
         n,
         r.filter(
            (c) =>
               !(c === "a" + t && r.includes("c" + t)) &&
               !(c === "h" + t && r.includes("g" + t)),
         ),
      );
   }
}
function Ae(e, o) {
   for (let t in o)
      t === "__proto__" ||
         t === "constructor" ||
         !Object.prototype.hasOwnProperty.call(o, t) ||
         (Object.prototype.hasOwnProperty.call(e, t) && so(e[t]) && so(o[t])
            ? Ae(e[t], o[t])
            : (e[t] = o[t]));
}
function so(e) {
   if (typeof e != "object" || e === null) return !1;
   let o = Object.getPrototypeOf(e);
   return o === Object.prototype || o === null;
}
var O = (e, o) => (o.animation.enabled ? ht(e, o) : B(e, o));
function B(e, o) {
   let t = e(o);
   return (o.dom.redraw(), t);
}
var Ne = (e, o) => ({ key: e, pos: m(e), piece: o }),
   mt = (e, o) => o.sort((t, n) => W(e.pos, t.pos) - W(e.pos, n.pos))[0];
function bt(e, o) {
   let t = new Map(),
      n = [],
      r = new Map(),
      i = [],
      c = [],
      p = new Map(),
      d,
      a,
      s;
   for (let [l, f] of e) p.set(l, Ne(l, f));
   for (let l of Q)
      ((d = o.pieces.get(l)),
         (a = p.get(l)),
         d
            ? a
               ? Y(d, a.piece) || (i.push(a), c.push(Ne(l, d)))
               : c.push(Ne(l, d))
            : a && i.push(a));
   for (let l of c)
      ((a = mt(
         l,
         i.filter((f) => Y(l.piece, f.piece)),
      )),
         a &&
            ((s = [a.pos[0] - l.pos[0], a.pos[1] - l.pos[1]]),
            t.set(l.key, s.concat(s)),
            n.push(a.key)));
   for (let l of i) n.includes(l.key) || r.set(l.key, l.piece);
   return { anims: t, fadings: r };
}
function lo(e, o) {
   let t = e.animation.current;
   if (t === void 0) {
      e.dom.destroyed || e.dom.redrawNow();
      return;
   }
   let n = 1 - (o - t.start) * t.frequency;
   if (n <= 0) ((e.animation.current = void 0), e.dom.redrawNow());
   else {
      let r = vt(n);
      for (let i of t.plan.anims.values())
         ((i[2] = i[0] * r), (i[3] = i[1] * r));
      (e.dom.redrawNow(!0),
         requestAnimationFrame((i = performance.now()) => lo(e, i)));
   }
}
function ht(e, o) {
   let t = new Map(o.pieces),
      n = e(o),
      r = bt(t, o);
   if (r.anims.size || r.fadings.size) {
      let i = o.animation.current && o.animation.current.start;
      ((o.animation.current = {
         start: performance.now(),
         frequency: 1 / o.animation.duration,
         plan: r,
      }),
         i || lo(o, performance.now()));
   } else o.dom.redraw();
   return n;
}
var vt = (e) =>
   e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
var yt = ["green", "red", "blue", "yellow"];
function po(e, o) {
   if (o.touches && o.touches.length > 1) return;
   (o.stopPropagation(), o.preventDefault(), o.ctrlKey ? w(e) : ee(e));
   let t = T(o),
      n = E(t, h(e), e.dom.bounds());
   n &&
      ((e.drawable.current = {
         orig: n,
         pos: t,
         brush: St(o),
         snapToValidMove: e.drawable.defaultSnapToValidMove,
      }),
      uo(e));
}
function uo(e) {
   requestAnimationFrame(() => {
      let o = e.drawable.current;
      if (o) {
         let t = E(o.pos, h(e), e.dom.bounds());
         t || (o.snapToValidMove = !1);
         let n = o.snapToValidMove
            ? ao(o.orig, o.pos, h(e), e.dom.bounds())
            : t;
         (n !== o.mouseSq &&
            ((o.mouseSq = n),
            (o.dest = n !== o.orig ? n : void 0),
            e.dom.redrawNow()),
            uo(e));
      }
   });
}
function go(e, o) {
   e.drawable.current && (e.drawable.current.pos = T(o));
}
function fo(e) {
   let o = e.drawable.current;
   o && (o.mouseSq && wt(e.drawable, o), He(e));
}
function He(e) {
   e.drawable.current && ((e.drawable.current = void 0), e.dom.redraw());
}
function mo(e) {
   e.drawable.shapes.length &&
      ((e.drawable.shapes = []), e.dom.redraw(), bo(e.drawable));
}
var ue = (e, o) => e.orig === o.orig && e.dest === o.dest,
   Te = (e, o) => e.brush === o.brush;
function St(e) {
   let o = (e.shiftKey || e.ctrlKey) && re(e),
      t = e.altKey || e.metaKey || e.getModifierState?.("AltGraph");
   return yt[(o ? 1 : 0) + (t ? 2 : 0)];
}
function wt(e, o) {
   let t = e.shapes.find((n) => ue(n, o));
   (t && (e.shapes = e.shapes.filter((n) => !ue(n, o))),
      (!t || !Te(t, o)) &&
         e.shapes.push({ orig: o.orig, dest: o.dest, brush: o.brush }),
      bo(e));
}
function bo(e) {
   e.onChange && e.onChange(e.shapes);
}
function ho(e, o) {
   if (
      !(e.trustAllEvents || o.isTrusted) ||
      (o.buttons !== void 0 && o.buttons > 1) ||
      (o.touches && o.touches.length > 1)
   )
      return;
   let t = e.dom.bounds(),
      n = T(o),
      r = E(n, h(e), t);
   if (!r) return;
   let i = e.pieces.get(r),
      c = e.selected;
   if (
      (!c &&
         e.drawable.enabled &&
         (e.drawable.eraseOnMovablePieceClick ||
            !i ||
            i.color !== e.turnColor) &&
         mo(e),
      o.cancelable !== !1 &&
         (!o.touches || e.blockTouchScroll || i || c || Mt(e, n)))
   )
      o.preventDefault();
   else if (o.touches) return;
   let p = !!e.premovable.current,
      d = !!e.predroppable.current;
   ((e.stats.ctrlKey = o.ctrlKey),
      e.selected && le(e, e.selected, r) ? O((l) => J(l, r), e) : J(e, r));
   let a = e.selected === r,
      s = Po(e, r);
   if (i && s && a && no(e, r)) {
      ((e.draggable.current = {
         orig: r,
         piece: i,
         origPos: n,
         pos: n,
         started: e.draggable.autoDistance && e.stats.dragged,
         element: s,
         previouslySelected: c,
         originTarget: o.target,
         keyHasChanged: !1,
      }),
         (s.cgDragging = !0),
         s.classList.add("dragging"));
      let l = e.dom.elements.ghost;
      (l &&
         ((l.className = `ghost ${i.color} ${i.role}`),
         x(l, $(t)(m(r), h(e))),
         q(l, !0)),
         Re(e));
   } else (p && K(e), d && D(e));
   e.dom.redraw();
}
function Mt(e, o) {
   let t = h(e),
      n = e.dom.bounds(),
      r = Math.pow((e.touchIgnoreRadius * n.width) / 16, 2) * 2;
   for (let i of e.pieces.keys()) {
      let c = ie(i, t, n);
      if (W(c, o) <= r) return !0;
   }
   return !1;
}
function vo(e, o, t, n) {
   let r = "a0";
   (e.pieces.set(r, o), e.dom.redraw());
   let i = T(t);
   ((e.draggable.current = {
      orig: r,
      piece: o,
      origPos: i,
      pos: i,
      started: !0,
      element: () => Po(e, r),
      originTarget: t.target,
      newPiece: !0,
      force: !!n,
      keyHasChanged: !1,
   }),
      Re(e));
}
function Re(e) {
   requestAnimationFrame(() => {
      let o = e.draggable.current;
      if (!o) return;
      e.animation.current?.plan.anims.has(o.orig) &&
         (e.animation.current = void 0);
      let t = e.pieces.get(o.orig);
      if (!t || !Y(t, o.piece)) j(e);
      else if (
         (!o.started &&
            W(o.pos, o.origPos) >= Math.pow(e.draggable.distance, 2) &&
            (o.started = !0),
         o.started)
      ) {
         if (typeof o.element == "function") {
            let r = o.element();
            if (!r) return;
            ((r.cgDragging = !0), r.classList.add("dragging"), (o.element = r));
         }
         let n = e.dom.bounds();
         (x(o.element, [
            o.pos[0] - n.left - n.width / 16,
            o.pos[1] - n.top - n.height / 16,
         ]),
            (o.keyHasChanged ||= o.orig !== E(o.pos, h(e), n)));
      }
      Re(e);
   });
}
function yo(e, o) {
   e.draggable.current &&
      (!o.touches || o.touches.length < 2) &&
      (e.draggable.current.pos = T(o));
}
function So(e, o) {
   let t = e.draggable.current;
   if (!t) return;
   if (
      (o.type === "touchend" && o.cancelable !== !1 && o.preventDefault(),
      o.type === "touchend" && t.originTarget !== o.target && !t.newPiece)
   ) {
      e.draggable.current = void 0;
      return;
   }
   (K(e), D(e));
   let n = T(o) || t.pos,
      r = E(n, h(e), e.dom.bounds());
   (r && t.started && t.orig !== r
      ? t.newPiece
         ? se(e, t.orig, r, t.force)
         : ((e.stats.ctrlKey = o.ctrlKey),
           Me(e, t.orig, r) && (e.stats.dragged = !0))
      : t.newPiece
        ? e.pieces.delete(t.orig)
        : e.draggable.deleteOnDropOff &&
          !r &&
          (e.pieces.delete(t.orig), P(e.events.change)),
      (t.orig === t.previouslySelected || t.keyHasChanged) &&
      (t.orig === r || !r)
         ? w(e)
         : e.selectable.enabled || w(e),
      wo(e),
      (e.draggable.current = void 0),
      e.dom.redraw());
}
function j(e) {
   let o = e.draggable.current;
   o &&
      (o.newPiece && e.pieces.delete(o.orig),
      (e.draggable.current = void 0),
      w(e),
      wo(e),
      e.dom.redraw());
}
function wo(e) {
   let o = e.dom.elements;
   o.ghost && q(o.ghost, !1);
}
function Po(e, o) {
   let t = e.dom.elements.board.firstChild;
   for (; t; ) {
      if (t.cgKey === o && t.tagName === "PIECE") return t;
      t = t.nextSibling;
   }
}
function xo(e, o) {
   ((e.exploding = { stage: 1, keys: o }),
      e.dom.redraw(),
      setTimeout(() => {
         (Mo(e, 2), setTimeout(() => Mo(e, void 0), 120));
      }, 120));
}
function Mo(e, o) {
   e.exploding &&
      (o ? (e.exploding.stage = o) : (e.exploding = void 0), e.dom.redraw());
}
function Co(e, o) {
   function t() {
      (Ye(e), o());
   }
   return {
      set(n) {
         (n.orientation && n.orientation !== e.orientation && t(),
            Ee(e, n),
            (n.fen ? O : B)((r) => pe(r, n), e));
      },
      state: e,
      getFen: () => co(e.pieces),
      toggleOrientation: t,
      setPieces(n) {
         O((r) => Je(r, n), e);
      },
      selectSquare(n, r) {
         n ? O((i) => J(i, n, r), e) : e.selected && (w(e), e.dom.redraw());
      },
      move(n, r) {
         O((i) => Pe(i, n, r), e);
      },
      newPiece(n, r) {
         O((i) => ce(i, n, r), e);
      },
      playPremove() {
         if (e.premovable.current) {
            if (O(ro, e)) return !0;
            e.dom.redraw();
         }
         return !1;
      },
      playPredrop(n) {
         if (e.predroppable.current) {
            let r = io(e, n);
            return (e.dom.redraw(), r);
         }
         return !1;
      },
      cancelPremove() {
         B(K, e);
      },
      cancelPredrop() {
         B(D, e);
      },
      cancelMove() {
         B((n) => {
            (ee(n), j(n));
         }, e);
      },
      stop() {
         B((n) => {
            (ke(n), j(n));
         }, e);
      },
      explode(n) {
         xo(e, n);
      },
      setAutoShapes(n) {
         B((r) => (r.drawable.autoShapes = n), e);
      },
      setShapes(n) {
         B((r) => (r.drawable.shapes = n.slice()), e);
      },
      getKeyAtDomPos(n) {
         return E(n, h(e), e.dom.bounds());
      },
      redrawAll: o,
      dragNewPiece(n, r, i) {
         vo(e, n, r, i);
      },
      destroy() {
         (ke(e), e.dom.unbind && e.dom.unbind(), (e.dom.destroyed = !0));
      },
   };
}
function ko() {
   return {
      pieces: de(De),
      orientation: "white",
      turnColor: "white",
      coordinates: !0,
      coordinatesOnSquares: !1,
      ranksPosition: "right",
      autoCastle: !0,
      viewOnly: !1,
      disableContextMenu: !1,
      addPieceZIndex: !1,
      blockTouchScroll: !1,
      touchIgnoreRadius: 1,
      pieceKey: !1,
      trustAllEvents: !1,
      highlight: { lastMove: !0, check: !0 },
      animation: { enabled: !0, duration: 200 },
      movable: {
         free: !0,
         color: "both",
         showDests: !0,
         events: {},
         rookCastle: !0,
      },
      premovable: {
         enabled: !0,
         showDests: !0,
         castle: !0,
         additionalPremoveRequirements: (e) => !0,
         events: {},
      },
      predroppable: { enabled: !1, events: {} },
      draggable: {
         enabled: !0,
         distance: 3,
         autoDistance: !0,
         showGhost: !0,
         deleteOnDropOff: !1,
      },
      dropmode: { active: !1 },
      selectable: { enabled: !0 },
      stats: { dragged: !("ontouchstart" in window) },
      events: {},
      drawable: {
         enabled: !0,
         visible: !0,
         defaultSnapToValidMove: !0,
         eraseOnMovablePieceClick: !0,
         shapes: [],
         autoShapes: [],
         brushes: {
            green: { key: "g", color: "#15781B", opacity: 1, lineWidth: 10 },
            red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 },
            blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 },
            yellow: { key: "y", color: "#e68f00", opacity: 1, lineWidth: 10 },
            paleBlue: {
               key: "pb",
               color: "#003088",
               opacity: 0.4,
               lineWidth: 15,
            },
            paleGreen: {
               key: "pg",
               color: "#15781B",
               opacity: 0.4,
               lineWidth: 15,
            },
            paleRed: {
               key: "pr",
               color: "#882020",
               opacity: 0.4,
               lineWidth: 15,
            },
            paleGrey: {
               key: "pgr",
               color: "#4a4a4a",
               opacity: 0.35,
               lineWidth: 15,
            },
            purple: {
               key: "purple",
               color: "#68217a",
               opacity: 0.65,
               lineWidth: 10,
            },
            pink: {
               key: "pink",
               color: "#ee2080",
               opacity: 0.5,
               lineWidth: 10,
            },
            white: { key: "white", color: "white", opacity: 1, lineWidth: 10 },
            paleWhite: {
               key: "pwhite",
               color: "white",
               opacity: 0.6,
               lineWidth: 10,
            },
         },
         prevSvgHash: "",
      },
      hold: ze(),
   };
}
function Ao() {
   let e = v("defs"),
      o = S(v("filter"), { id: "cg-filter-blur" });
   return (
      o.appendChild(S(v("feGaussianBlur"), { stdDeviation: "0.013" })),
      e.appendChild(o),
      e
   );
}
function No(e, o) {
   let t = e.drawable,
      n = t.current,
      r = n && n.mouseSq ? n : void 0,
      i = new Map(),
      c = e.dom.bounds(),
      p = t.autoShapes.filter((l) => !l.piece);
   for (let l of t.shapes.concat(p).concat(r ? [r] : [])) {
      if (!l.dest) continue;
      let f = i.get(l.dest) ?? new Set(),
         g = fe(ge(m(l.orig), e.orientation), c),
         u = fe(ge(m(l.dest), e.orientation), c);
      (f.add(Vo(Lo(g, u))), i.set(l.dest, f));
   }
   let d = [],
      a = r ? t.shapes.findIndex((l) => ue(l, r) && Te(l, r)) : -1;
   for (let [l, f] of t.shapes.concat(p).entries()) {
      let g = a !== -1 && a === l;
      d.push({
         shape: f,
         current: !1,
         pendingErase: g,
         hash: Ko(f, qe(f.dest, i), !1, c, g, Eo(f.dest, i)),
      });
   }
   r &&
      a === -1 &&
      d.push({
         shape: r,
         current: !0,
         hash: Ko(r, qe(r.dest, i), !0, c, !1, Eo(r.dest, i)),
         pendingErase: !1,
      });
   let s = d.map((l) => l.hash).join(";");
   s !== e.drawable.prevSvgHash &&
      ((e.drawable.prevSvgHash = s),
      Ct(t, d, o),
      kt(d, o, (l) => Et(e, l, t.brushes, i, c)));
}
function Ct(e, o, t) {
   for (let n of [t.shapes, t.shapesBelow]) {
      let r = n.querySelector("defs"),
         i = o.filter((a) => (n === t.shapesBelow) == !!a.shape.below),
         c = new Map();
      for (let a of i.filter((s) => s.shape.dest && s.shape.brush)) {
         let s = qo(e.brushes[a.shape.brush], a.shape.modifiers),
            { key: l, color: f } = Oo(a.shape);
         (l && f && c.set(l, { key: l, color: f, opacity: 1, lineWidth: 1 }),
            c.set(s.key, s));
      }
      let p = new Set(),
         d = r.firstElementChild;
      for (; d; ) (p.add(d.getAttribute("cgKey")), (d = d.nextElementSibling));
      for (let [a, s] of c.entries()) p.has(a) || r.appendChild(Ht(s));
   }
}
function kt(e, o, t) {
   for (let [n, r] of [
      [o.shapes, o.custom],
      [o.shapesBelow, o.customBelow],
   ]) {
      let [i, c] = [n, r].map((a) => a.querySelector("g")),
         p = e.filter((a) => (n === o.shapesBelow) == !!a.shape.below),
         d = new Map();
      for (let a of p) d.set(a.hash, !1);
      for (let a of [i, c]) {
         let s = [],
            l = a.firstElementChild,
            f;
         for (; l; )
            ((f = l.getAttribute("cgHash")),
               d.has(f) ? d.set(f, !0) : s.push(l),
               (l = l.nextElementSibling));
         for (let g of s) a.removeChild(g);
      }
      for (let a of p.filter((s) => !d.get(s.hash)))
         for (let s of t(a))
            s.isCustom ? c.appendChild(s.el) : i.appendChild(s.el);
   }
}
function Ko(
   {
      orig: e,
      dest: o,
      brush: t,
      piece: n,
      modifiers: r,
      customSvg: i,
      label: c,
      below: p,
   },
   d,
   a,
   s,
   l,
   f,
) {
   return [
      s.width,
      s.height,
      a,
      l && "pendingErase",
      f,
      e,
      o,
      t,
      d && "-",
      n && Kt(n),
      r && Dt(r),
      i && `custom-${Do(i.html)},${i.center?.[0] ?? "o"}`,
      c && `label-${Do(c.text)}`,
      p && "below",
   ]
      .filter((g) => g)
      .join(",");
}
var Kt = (e) => [e.color, e.role, e.scale].filter((o) => o).join(","),
   Dt = (e) => [e.lineWidth, e.hilite].filter((o) => o).join(",");
function Do(e) {
   let o = 0;
   for (let t = 0; t < e.length; t++)
      o = ((o << 5) - o + e.charCodeAt(t)) >>> 0;
   return o.toString();
}
function Et(e, { shape: o, current: t, pendingErase: n, hash: r }, i, c, p) {
   let d = fe(ge(m(o.orig), e.orientation), p),
      a = o.dest ? fe(ge(m(o.dest), e.orientation), p) : d,
      s = o.brush && qo(i[o.brush], o.modifiers),
      l = c.get(o.dest),
      f = [];
   if (s) {
      let g = S(v("g"), { cgHash: r });
      (f.push({ el: g }),
         d[0] !== a[0] || d[1] !== a[1]
            ? g.appendChild(Nt(o, s, d, a, t, qe(o.dest, c), n))
            : g.appendChild(At(i[o.brush], d, t, p, n)));
   }
   if (o.label) {
      let g = o.label;
      g.fill ??= o.brush && i[o.brush].color;
      let u = o.brush ? void 0 : "tr";
      f.push({ el: Tt(g, r, d, a, l, u), isCustom: !0 });
   }
   if (o.customSvg) {
      let g = o.customSvg.center ?? "orig",
         [u, A] =
            g === "label"
               ? Go(d, a, l).map((y) => y - 0.5)
               : g === "dest"
                 ? a
                 : d,
         k = S(v("g"), { transform: `translate(${u},${A})`, cgHash: r });
      ((k.innerHTML = `<svg width="1" height="1" viewBox="0 0 100 100">${o.customSvg.html}</svg>`),
         f.push({ el: k, isCustom: !0 }));
   }
   return f;
}
function At(e, o, t, n, r) {
   let i = Rt(),
      c = (n.width + n.height) / (4 * Math.max(n.width, n.height));
   return S(v("circle"), {
      stroke: e.color,
      "stroke-width": i[t ? 0 : 1],
      fill: "none",
      opacity: Bo(e, t, r),
      cx: o[0],
      cy: o[1],
      r: c - i[1] / 2,
   });
}
function Nt(e, o, t, n, r, i, c) {
   function p(s) {
      let l = Ot(i && !r),
         f = n[0] - t[0],
         g = n[1] - t[1],
         u = Math.atan2(g, f),
         A = Math.cos(u) * l,
         k = Math.sin(u) * l,
         y = Oo(e);
      return S(v("line"), {
         stroke: s ? y.color : o.color,
         "stroke-width": qt(o, r) * (s ? 1.14 : 1),
         "stroke-linecap": "round",
         "marker-end": `url(#arrowhead-${s ? y.key : o.key})`,
         opacity: e.modifiers?.hilite && !c ? 1 : Bo(o, r, c),
         x1: t[0],
         y1: t[1],
         x2: n[0] - A,
         y2: n[1] - k,
      });
   }
   if (!e.modifiers?.hilite) return p(!1);
   let d = S(v("g"), { opacity: o.opacity }),
      a = S(v("g"), { filter: "url(#cg-filter-blur)" });
   return (
      a.appendChild(Bt(t, n)),
      a.appendChild(p(!0)),
      d.appendChild(a),
      d.appendChild(p(!1)),
      d
   );
}
function Ht(e) {
   let o = S(v("marker"), {
      id: "arrowhead-" + e.key,
      orient: "auto",
      overflow: "visible",
      markerWidth: 4,
      markerHeight: 4,
      refX: e.key.startsWith("hilite") ? 1.86 : 2.05,
      refY: 2,
   });
   return (
      o.appendChild(S(v("path"), { d: "M0,0 V4 L3,2 Z", fill: e.color })),
      o.setAttribute("cgKey", e.key),
      o
   );
}
function Tt(e, o, t, n, r, i) {
   let p = 0.4 * 0.75 ** e.text.length,
      d = Go(t, n, r),
      a = i === "tr" ? 0.4 : 0,
      s = S(v("g"), {
         transform: `translate(${d[0] + a},${d[1] - a})`,
         cgHash: o,
      });
   s.appendChild(
      S(v("circle"), {
         r: 0.4 / 2,
         "fill-opacity": i ? 1 : 0.8,
         "stroke-opacity": i ? 1 : 0.7,
         "stroke-width": 0.03,
         fill: e.fill ?? "#666",
         stroke: "white",
      }),
   );
   let l = S(v("text"), {
      "font-size": p,
      "font-family": "Noto Sans",
      "text-anchor": "middle",
      fill: "white",
      y: 0.13 * 0.75 ** e.text.length,
   });
   return ((l.innerHTML = e.text), s.appendChild(l), s);
}
var ge = (e, o) => (o === "white" ? e : [7 - e[0], 7 - e[1]]),
   Ho = (e, o) => ((e % o) + o) % o,
   To = (e, o) => Ho(e + o, 16),
   Ro = (e) =>
      [...e].some((o) => [-3, -2, -1, 1, 2, 3].some((t) => e.has(To(o, t)))),
   qe = (e, o) => !!e && o.has(e) && Ro(o.get(e)),
   v = (e) => document.createElementNS("http://www.w3.org/2000/svg", e),
   Eo = (e, o) => (e && o.has(e) ? o.get(e).size : 0);
function S(e, o) {
   for (let t in o)
      Object.prototype.hasOwnProperty.call(o, t) && e.setAttribute(t, o[t]);
   return e;
}
var qo = (e, o) =>
      o
         ? {
              color: e.color,
              opacity: Math.round(e.opacity * 10) / 10,
              lineWidth: Math.round(o.lineWidth || e.lineWidth),
              key: [e.key, o.lineWidth].filter((t) => t).join(""),
           }
         : e,
   Rt = () => [3 / 64, 4 / 64],
   qt = (e, o) => ((e.lineWidth || 10) * (o ? 0.85 : 1)) / 64;
function Oo(e) {
   let o = e.modifiers?.hilite;
   return { key: o && `hilite-${o.replace("#", "")}`, color: o };
}
var Bo = (e, o, t) => (e.opacity || 1) * (t ? 0.6 : o ? 0.9 : 1),
   Ot = (e) => (e ? 20 : 10) / 64;
function fe(e, o) {
   let t = Math.min(1, o.width / o.height),
      n = Math.min(1, o.height / o.width);
   return [(e[0] - 3.5) * t, (3.5 - e[1]) * n];
}
function Bt(e, o) {
   let t = {
      from: [
         Math.floor(Math.min(e[0], o[0])),
         Math.floor(Math.min(e[1], o[1])),
      ],
      to: [Math.ceil(Math.max(e[0], o[0])), Math.ceil(Math.max(e[1], o[1]))],
   };
   return S(v("rect"), {
      x: t.from[0],
      y: t.from[1],
      width: t.to[0] - t.from[0],
      height: t.to[1] - t.from[1],
      fill: "none",
      stroke: "none",
   });
}
var Vo = (e) => Ho(Math.round((e * 8) / Math.PI), 16),
   Lo = (e, o) => Math.atan2(o[1] - e[1], o[0] - e[0]) + Math.PI,
   Vt = (e, o) =>
      Math.sqrt([e[0] - o[0], e[1] - o[1]].reduce((t, n) => t + n * n, 0));
function Go(e, o, t) {
   let n = Vt(e, o),
      r = Lo(e, o);
   if (t && ((n -= 33 / 64), Ro(t))) {
      n -= 10 / 64;
      let i = Vo(r);
      i & 1 && [-1, 1].some((c) => t.has(To(i, c))) && (n -= 0.4);
   }
   return [e[0] - Math.cos(r) * n, e[1] - Math.sin(r) * n].map((i) => i + 0.5);
}
function Wo(e, o) {
   ((e.innerHTML = ""), e.classList.add("cg-wrap"));
   for (let s of Ge)
      e.classList.toggle("orientation-" + s, o.orientation === s);
   e.classList.toggle("manipulable", !o.viewOnly);
   let t = C("cg-container");
   e.appendChild(t);
   let n = C("cg-board");
   t.appendChild(n);
   let r, i, c, p, d;
   if (
      (o.drawable.visible &&
         (([r, i] = ["cg-shapes-below", "cg-shapes"].map((s) => Fo(s, !0))),
         ([c, p] = ["cg-custom-below", "cg-custom-svgs"].map((s) => Fo(s, !1))),
         (d = C("cg-auto-pieces")),
         t.appendChild(r),
         t.appendChild(c),
         t.appendChild(i),
         t.appendChild(p),
         t.appendChild(d)),
      o.coordinates)
   ) {
      let s = o.orientation === "black" ? " black" : "",
         l = o.ranksPosition === "left" ? " left" : "";
      if (o.coordinatesOnSquares) {
         let f = o.orientation === "white" ? (g) => g + 1 : (g) => 8 - g;
         I.forEach((g, u) =>
            t.appendChild(
               Oe(
                  U.map((A) => g + A),
                  "squares rank" + f(u) + s + l,
                  u % 2 === 0 ? "black" : "white",
               ),
            ),
         );
      } else
         (t.appendChild(
            Oe(
               U,
               "ranks" + s + l,
               (o.ranksPosition === "right") == (o.orientation === "white")
                  ? "white"
                  : "black",
            ),
         ),
            t.appendChild(Oe(I, "files" + s, F(o.orientation))));
   }
   let a;
   return (
      !o.viewOnly &&
         o.draggable.enabled &&
         o.draggable.showGhost &&
         ((a = C("piece", "ghost")), q(a, !1), t.appendChild(a)),
      {
         board: n,
         container: t,
         wrap: e,
         ghost: a,
         shapes: i,
         shapesBelow: r,
         custom: p,
         customBelow: c,
         autoPieces: d,
      }
   );
}
function Fo(e, o) {
   let t = S(v("svg"), {
      class: e,
      viewBox: o ? "-4 -4 8 8" : "-3.5 -3.5 8 8",
      preserveAspectRatio: "xMidYMid slice",
   });
   return (o && t.appendChild(Ao()), t.appendChild(v("g")), t);
}
function Oe(e, o, t) {
   let n = C("coords", o),
      r;
   return (
      e.forEach((i, c) => {
         let p = c % 2 === (t === "white" ? 0 : 1);
         ((r = C("coord", `coord-${p ? "light" : "dark"}`)),
            (r.textContent = i),
            n.appendChild(r));
      }),
      n
   );
}
function $o(e, o) {
   if (!e.dropmode.active) return;
   (K(e), D(e));
   let t = e.dropmode.piece;
   if (t) {
      e.pieces.set("a0", t);
      let n = T(o),
         r = n && E(n, h(e), e.dom.bounds());
      r && se(e, "a0", r);
   }
   e.dom.redraw();
}
function Io(e, o) {
   let t = e.dom.elements.board;
   if (
      ("ResizeObserver" in window &&
         new ResizeObserver(o).observe(e.dom.elements.wrap),
      (e.disableContextMenu || e.drawable.enabled) &&
         t.addEventListener("contextmenu", (r) => r.preventDefault()),
      e.viewOnly)
   )
      return;
   let n = Gt(e);
   (t.addEventListener("touchstart", n, { passive: !1 }),
      t.addEventListener("mousedown", n, { passive: !1 }));
}
function jo(e, o) {
   let t = [];
   if (
      ("ResizeObserver" in window ||
         t.push(oe(document.body, "chessground.resize", o)),
      !e.viewOnly)
   ) {
      let n = zo(e, yo, go),
         r = zo(e, So, fo);
      for (let c of ["touchmove", "mousemove"]) t.push(oe(document, c, n));
      for (let c of ["touchend", "mouseup"]) t.push(oe(document, c, r));
      let i = () => e.dom.bounds.clear();
      (t.push(oe(document, "scroll", i, { capture: !0, passive: !0 })),
         t.push(oe(window, "resize", i, { passive: !0 })));
   }
   return () => t.forEach((n) => n());
}
function oe(e, o, t, n) {
   return (e.addEventListener(o, t, n), () => e.removeEventListener(o, t, n));
}
var Gt = (e) => (o) => {
      e.draggable.current
         ? j(e)
         : e.drawable.current
           ? He(e)
           : o.shiftKey || re(o)
             ? e.drawable.enabled && po(e, o)
             : e.viewOnly || (e.dropmode.active ? $o(e, o) : ho(e, o));
   },
   zo = (e, o, t) => (n) => {
      e.drawable.current
         ? e.drawable.enabled && t(e, n)
         : e.viewOnly || o(e, n);
   };
function Uo(e) {
   let o = h(e),
      t = $(e.dom.bounds()),
      n = e.dom.elements.board,
      r = e.pieces,
      i = e.animation.current,
      c = i ? i.plan.anims : new Map(),
      p = i ? i.plan.fadings : new Map(),
      d = e.draggable.current,
      a = new Set(),
      s = new Map(),
      l = zt(e),
      f = new Map(),
      g,
      u,
      A,
      k,
      y,
      _,
      me,
      N,
      X;
   for (u = n.firstChild; u; ) {
      if (((g = u.cgKey), _o(u)))
         if (
            ((A = r.get(g)),
            (y = c.get(g)),
            (_ = p.get(g)),
            (k = u.cgPiece),
            u.cgDragging &&
               (!d || d.orig !== g) &&
               (u.classList.remove("dragging"),
               x(u, t(m(g), o)),
               (u.cgDragging = !1)),
            !_ &&
               u.cgFading &&
               ((u.cgFading = !1), u.classList.remove("fading")),
            A)
         ) {
            if (y && u.cgAnimating && k === te(A)) {
               let b = m(g);
               ((b[0] += y[2]),
                  (b[1] += y[3]),
                  u.classList.add("anim"),
                  x(u, t(b, o)));
            } else
               u.cgAnimating &&
                  ((u.cgAnimating = !1),
                  u.classList.remove("anim"),
                  x(u, t(m(g), o)),
                  e.addPieceZIndex && (u.style.zIndex = Be(m(g), o)));
            k === te(A) && (!_ || !u.cgFading)
               ? a.add(g)
               : _ && k === te(_)
                 ? (u.classList.add("fading"), (u.cgFading = !0))
                 : Ve(s, k, u);
         } else Ve(s, k, u);
      else if (Xo(u)) {
         let b = u.className;
         l.get(g) === b ? (q(u, !0), l.delete(g)) : Ve(f, b, u);
      }
      u = u.nextSibling;
   }
   for (let [b, z] of l) {
      X = f.get(z)?.pop();
      let M = t(m(b), o);
      if (X) ((X.cgKey = b), x(X, M), q(X, !0));
      else {
         let H = C("square", z);
         ((H.cgKey = b), x(H, M), n.insertBefore(H, n.firstChild));
      }
   }
   for (let [b, z] of f.entries()) for (let M of z) q(M, !1);
   for (let [b, z] of r)
      if (((y = c.get(b)), !a.has(b)))
         if (((me = s.get(te(z))), (N = me && me.pop()), N)) {
            ((N.cgKey = b),
               N.cgFading && (N.classList.remove("fading"), (N.cgFading = !1)));
            let M = m(b);
            (e.addPieceZIndex && (N.style.zIndex = Be(M, o)),
               y &&
                  ((N.cgAnimating = !0),
                  N.classList.add("anim"),
                  (M[0] += y[2]),
                  (M[1] += y[3])),
               x(N, t(M, o)));
         } else {
            let M = te(z),
               H = C("piece", M),
               ne = m(b);
            ((H.cgPiece = M),
               (H.cgKey = b),
               y && ((H.cgAnimating = !0), (ne[0] += y[2]), (ne[1] += y[3])),
               x(H, t(ne, o)),
               e.addPieceZIndex && (H.style.zIndex = Be(ne, o)),
               n.appendChild(H));
         }
   for (let b of s.values()) Wt(e, b);
}
function Zo(e) {
   let o = h(e),
      t = $(e.dom.bounds()),
      n = e.dom.elements.board.firstChild;
   for (; n; )
      (((_o(n) && !n.cgAnimating) || Xo(n)) && x(n, t(m(n.cgKey), o)),
         (n = n.nextSibling));
}
function Le(e) {
   let o = e.dom.elements.wrap.getBoundingClientRect(),
      t = e.dom.elements.container,
      n = o.height / o.width,
      r =
         (Math.floor((o.width * window.devicePixelRatio) / 8) * 8) /
         window.devicePixelRatio,
      i = r * n;
   ((t.style.width = r + "px"),
      (t.style.height = i + "px"),
      e.dom.bounds.clear(),
      e.addDimensionsCssVarsTo?.style.setProperty("---cg-width", r + "px"),
      e.addDimensionsCssVarsTo?.style.setProperty("---cg-height", i + "px"));
}
var _o = (e) => e.tagName === "PIECE",
   Xo = (e) => e.tagName === "SQUARE";
function Wt(e, o) {
   for (let t of o) e.dom.elements.board.removeChild(t);
}
function Be(e, o) {
   let n = e[1];
   return `${o ? 10 - n : 3 + n}`;
}
var te = (e) => `${e.color} ${e.role}`,
   $t = (e, o) =>
      e.lastMove?.[1] &&
      !e.pieces.has(e.lastMove[1]) &&
      e.lastMove[0][0] === "e" &&
      ["h", "a"].includes(e.lastMove[1][0]) &&
      e.lastMove[0][1] === e.lastMove[1][1] &&
      _e(...m(e.lastMove[0]), ...m(e.lastMove[1])).some((t) => e.pieces.has(t))
         ? (o > e.lastMove[0] ? "g" : "c") + o[1]
         : o;
function zt(e) {
   let o = new Map();
   if (e.lastMove && e.highlight.lastMove)
      for (let [r, i] of e.lastMove.entries())
         V(o, r === 1 ? $t(e, i) : i, "last-move");
   if (
      (e.check && e.highlight.check && V(o, e.check, "check"),
      e.selected && (V(o, e.selected, "selected"), e.movable.showDests))
   ) {
      for (let r of e.movable.dests?.get(e.selected) ?? [])
         V(o, r, "move-dest" + (e.pieces.has(r) ? " oc" : ""));
      for (let r of e.premovable.customDests?.get(e.selected) ??
         e.premovable.dests ??
         [])
         V(o, r, "premove-dest" + (e.pieces.has(r) ? " oc" : ""));
   }
   let t = e.premovable.current;
   if (t) for (let r of t) V(o, r, "current-premove");
   else
      e.predroppable.current &&
         V(o, e.predroppable.current.key, "current-premove");
   let n = e.exploding;
   if (n) for (let r of n.keys) V(o, r, "exploding" + n.stage);
   return (
      e.highlight.custom &&
         e.highlight.custom.forEach((r, i) => {
            V(o, i, r);
         }),
      o
   );
}
function V(e, o, t) {
   let n = e.get(o);
   n ? e.set(o, `${n} ${t}`) : e.set(o, t);
}
function Ve(e, o, t) {
   let n = e.get(o);
   n ? n.push(t) : e.set(o, [t]);
}
function Qo(e, o, t) {
   let n = new Map(),
      r = [];
   for (let p of e) n.set(p.hash, !1);
   let i = o.firstElementChild,
      c;
   for (; i; )
      ((c = i.getAttribute("cgHash")),
         n.has(c) ? n.set(c, !0) : r.push(i),
         (i = i.nextElementSibling));
   for (let p of r) o.removeChild(p);
   for (let p of e) n.get(p.hash) || o.appendChild(t(p));
}
function Yo(e, o) {
   let n = e.drawable.autoShapes
      .filter((r) => r.piece)
      .map((r) => ({ shape: r, hash: jt(r), current: !1, pendingErase: !1 }));
   Qo(n, o, (r) => It(e, r, e.dom.bounds()));
}
function Jo(e) {
   let o = h(e),
      t = $(e.dom.bounds()),
      n = e.dom.elements.autoPieces?.firstChild;
   for (; n; ) (ve(n, t(m(n.cgKey), o), n.cgScale), (n = n.nextSibling));
}
function It(e, { shape: o, hash: t }, n) {
   let r = o.orig,
      i = o.piece?.role,
      c = o.piece?.color,
      p = o.piece?.scale,
      d = C("piece", `${i} ${c}`);
   return (
      d.setAttribute("cgHash", t),
      (d.cgKey = r),
      (d.cgScale = p),
      ve(d, $(n)(m(r), h(e)), p),
      d
   );
}
var jt = (e) =>
   [e.orig, e.piece?.role, e.piece?.color, e.piece?.scale].join(",");
function or({ el: e, config: o }) {
   return Zt(e, o);
}
function Zt(e, o) {
   let t = ko();
   pe(t, o || {});
   function n() {
      let r = "dom" in t ? t.dom.unbind : void 0,
         i = Wo(e, t),
         c = he(() => i.board.getBoundingClientRect()),
         p = (s) => {
            (Uo(a),
               i.autoPieces && Yo(a, i.autoPieces),
               !s && i.shapes && No(a, i));
         },
         d = () => {
            (Le(a), Zo(a), i.autoPieces && Jo(a));
         },
         a = t;
      return (
         (a.dom = {
            elements: i,
            bounds: c,
            redraw: _t(p),
            redrawNow: p,
            unbind: r,
         }),
         (a.drawable.prevSvgHash = ""),
         Le(a),
         p(!1),
         Io(a, d),
         r || (a.dom.unbind = jo(a, d)),
         a.events.insert && a.events.insert(i),
         a
      );
   }
   return Co(n(), n);
}
function _t(e) {
   let o = !1;
   return () => {
      o ||
         ((o = !0),
         requestAnimationFrame(() => {
            (e(), (o = !1));
         }));
   };
}
export { Zt as Chessground, or as initModule };
